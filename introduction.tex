\chapter{Introduction}
WISI Norden AB, previously A2B Electronics, is a Swedish company 
founded in 1997. The company is a developer of head-end cable-TV 
distribution systems. WISI Norden develops and designs both hardware 
and software, with the purpose of providing Digital TV solutions. 

The purpose of this thesis has been to find a replacement to the 
currently implemented scrambler, located in the head-end solutions. The
previous scrambler needed to be replaced, since it was designed in 
1994 and was supposed to last for ten years. The scrambler is used to 
render the digital television streams unreadable if the user does not 
subscribe to the encoded channels. 

The task was to evaluate and analyze a few potential scrambling 
algorithms, and then choose one algorithm to implement in WISI 
Norden's devices.

\section{Background}
The formerly used \emph{common scrambling algorithm} (CSA) has due to 
recent progresses in television broadcasting become obsolete. CSA was 
designed to make software descrambling hard, if possible, while making 
hardware descrambling fast. 

There are two suggested replacements of CSA. The first one is named 
after the CSA, and is called CSA3. The reason as to why it is not 
called CSA2 is since there already exists an algorithm which is 
called CSA2. CSA2 is the same algorithm as CSA, just with a different
key-length. The second algorithm is the software-friendly descrambling 
algorithm CISSA. Both of them are based on the public Advanced 
Encryption Standard - 128 (commonly known as the AES-128). There are 
three versions of the AES, with varying numbers. The number depicts 
what key-length the AES uses.

WISI Norden wanted to evaluate the replacement algorithms, even 
though the CSA is still used in the DVB world. This was done to make 
sure that there was an alternative to the CSA, when other companies 
would start to switch scrambling methods. WISI Norden has also had some 
requests to implement other scrambling methods from clients.

\section{Problem specification}
The task was to analyze the possible replacements for the common 
scrambling algorithm, and decide which one was the most suitable 
replacement. After choosing an algorithm, that algorithm was to be 
implemented from scratch, making decisions to minimize the hardware 
usage while achieving the frequency used by the rest of the system. 
The decisions made were to be motivated either through simulations or 
reference litterature.

There were two proposed replacements to be compared and analyzed 
to find what made one of them software-friendly and the other one 
hardware-friendly. 

\section{Constraints}
The thesis has been limited to implement the scrambing algorithm 
chosen in consent between the author and the supervisor at WISI 
Norden. The algorithm that was chosen, after analysis of the two 
proposed algorithms, was the AES128 algorithm in CBC-mode (chapter 
\ref{sec:BlockCipher}) with a set IV, according to the CISSA standard. 
This corresponds to the CISSA algorithm \citep{DVB:2013}.The 
implementation is focused on minimizing the hardware usage, while 
achieving a throughput of at least 1 Gbits/s.

\section{Methodology}
The project was split into a set of tasks, to be performed in the 
order written below. Performing the tasks in this order was done to 
decrease the complexity of the seperate tasks.

\begin{itemize}
\item Litterature study
\item Choosing an algorithm
\item Design and test of entities
\item Implementation
\item Optimization
\end{itemize}

To gain some knowledge about cryptography, a litterature study was 
first conducted. This provided some insight into what the strenghts 
and weaknesses of the algorithms actually were. The AES cipher was 
chosen as an initial algortihm, since both of the proposed algorithms 
used the AES as a base. The other parts of the cipher, which ever was 
chosen, were to be added after the AES was finished. Using the 
gathered background information about how the algorithm worked made 
design and testing of the entities rather easy. The lower level 
entities were designed first, which allowed for easier testing of 
seperate parts of the system. Knowing that the functionality, of low 
level entities, was already present allowed for easier merging of 
entities. This led to the system being implemented through bottom-up 
design.
